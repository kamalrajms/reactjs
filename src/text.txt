 ##react styleing methods
    inline css
    app.css,index.css is globaly assigned
    css module.css

##props
    props.varialbeName   fun (props)
    Destructureing props  fun({var})

##hooks

    usestate
    useEffect
    useContext
    UseReducer
    useCallBack
    useRef
    useNavigate
    useParams 

##types of states

    local state =usestate,UseReducer =inside one components
    
    global state=useContext,redux  --across components

    server state = useEffect    --Remote data, api

    url state  -- useSearchparams,useParams  --routing info

    form state -- usestate   --user inputs



##usestate

    const[startingVariable,SETStatingVariaable]=usestate(initialvalue)

    useState is a React Hook that allows you to add state (data that can change over time) to a functional component.
    Normally, in JavaScript functions, variables disappear after the function runs. But with useState, React remembers values between re-renders.

## conditional rendering
## list rendering in react

## trenary opreator || logical operator

## forms & controlled components
    handling inputs

## useEffect
    
    useEffect is a Hook that let you perform side 
    effect in functionol components.
    
    like 
        fetching datas from api
        updating the browser browser
        starting /stoping timers

    useEffect(()=>{
        //code
    },[dependencies1,dependencies2....]) 

## Routing DOM

    routing DOM means navigating b/w different pages in a web application
    In traditional web sites ,clicking a link reloads the while pages. 
    in react (SAP) ,routing lets us changes the view without reloding  

    npm install react-router-DOM

##useRef
     userf is a react hook that give you box (.current) you can store anything
     num,str,obj,function,dom elemments

     updating it does not causes your component re-rendering

## useContext

   1) passing data from a parent component down to deeply nested child component is annoying.
    
    2) Normally,you have to pass props manually through each level called props drilling

    3) useContext lets you skip all the middle components and share data directly

## useReducer()

    const[state,dispatch]=useReducer(reducerFunction,initialvalue)

    state-- current state (like usestate)
    dispatch-- a function to tell the reducer what to does
    reducerFunction(state,action) -- the logical that return a new state
    initialvalue--starting value

## useCallBack()

    every time a component re-rendering,
    it creates a brand-new copy of every function inside it.

    even if the function code look exactly the same,
    React sees it as different because it's a new obyect in memory

    const variables= useCallBack(()=>{

    },[dependencies])